{"name":"stubby4node","tagline":"A configurable server for stubbing external systems during development. Uses Node.js and written in Coffeescript","body":"[![Build Status](https://secure.travis-ci.org/mrak/stubby4node.png?branch=master)](http://travis-ci.org/mrak/stubby4node)\r\n[![NPM version](https://badge.fury.io/js/stubby.png)](http://badge.fury.io/js/stubby)\r\n\r\nstubby4node\r\n===========\r\n\r\n## Table of Contents\r\n\r\n* [Installation](#installation)\r\n* [Requirements](#requirements)\r\n* [Starting the Server(s)](#starting-the-servers)\r\n* [Command-line Switches](#command-line-switches)\r\n* [Endpoint Configuration](#endpoint-configuration)\r\n* [Dynamic Token Replacement](#dynamic-token-replacement)\r\n* [The Admin Portal](#the-admin-portal)\r\n* [The Stubs Portal](#the-stubs-portal)\r\n* [Programmatic API](#programmatic-api)\r\n* [Running Tests](#running-tests)\r\n* [Contributing](#contributing)\r\n* [See Also](#see-also)\r\n* [TODO](#todo)\r\n* [NOTES](#notes)\r\n\r\n## Installation\r\n\r\n### via npm\r\n\r\n    npm install -g stubby\r\n\r\nThis will install `stubby` as a command in your `PATH`. Leave off the `-g` flag if you'd like to use stubby as an embedded module in your project.\r\n\r\n### via source\r\n\r\nYou need to have `coffee-script` installed on your system.\r\n\r\n    git clone git://github.com/Afmrak/stubby4node.git\r\n    cd stubby4node\r\n    coffee -o lib -c src\r\n    export PATH=$PATH:<pwd>/bin/stubby\r\n\r\n## Requirements\r\n\r\n* [node.js](http://nodejs.org/) (>=0.10.x)\r\n\r\nDevelopment is on x86-64 Linux.\r\n\r\n### Packaged\r\n\r\n* [JS-YAML](https://github.com/nodeca/js-yaml) for loading yaml files\r\n* [cloneextend](https://github.com/shimondoodkin/nodejs-clone-extend)\r\n\r\n### Optional (for development)\r\n\r\n* [grunt-cli](http://gruntjs.com)\r\n* [node-inspector](https://github.com/dannycoates/node-inspector)\r\n\r\n## Starting the Server(s)\r\n\r\nSome systems require you to `sudo` before running services on port certain ports (like 80)\r\n\r\n    [sudo] stubby\r\n\r\n## Command-line Switches\r\n\r\n```\r\nstubby [-a <port>] [-c <file>] [-d <file>] [-h] [-k <file>] [-l <hostname>] [-m] [-p <file>]\r\n       [-s <port>] [-t <port>] [-v] [-w]\r\n\r\n-a, --admin <port>          Port for admin portal. Defaults to 8889.\r\n-c, --cert <file>           Certificate file. Use with --key.\r\n-d, --data <file>           Data file to pre-load endoints. YAML or JSON format.\r\n-h, --help                  This help text.\r\n-k, --key <file>            Private key file. Use with --cert.\r\n-l, --location <hostname>   Hostname at which to bind stubby.\r\n-m, --mute                  Prevent stubby from printing to the console.\r\n-p, --pfx <file>            PFX file. Ignored if used with --key/--cert\r\n-s, --stubs <port>          Port for stubs portal. Defaults to 8882.\r\n-t, --tls <port>            Port for https stubs portal. Defaults to 7443.\r\n-v, --version               Prints stubby's version number.\r\n-w, --watch                 Auto-reload data file when edits are made.\r\n```\r\n\r\n## Endpoint Configuration\r\n\r\nThis section explains the usage, intent and behavior of each property on the `request` and `response` objects.\r\n\r\nHere is a fully-populated, unrealistic endpoint:\r\n```yaml\r\n-  request:\r\n      url: ^/your/awesome/endpoint$\r\n      method: POST\r\n      query:\r\n         exclamation: post requests can have query strings!\r\n      headers:\r\n         content-type: application/xml\r\n      post: >\r\n         <!xml blah=\"blah blah blah\">\r\n         <envelope>\r\n            <unaryTag/>\r\n         </envelope>\r\n      file: tryMyFirst.xml\r\n   response:\r\n    - status: 200\r\n      latency: 5000\r\n      headers:\r\n         content-type: application/xml\r\n         server: stubbedServer/4.2\r\n      body: >\r\n         <!xml blah=\"blah blah blah\">\r\n         <responseXML>\r\n            <content></content>\r\n         </responseXML>\r\n      file: responseData.xml\r\n    - status: 200\r\n      body: \"Haha!\"\r\n```\r\n\r\n### request\r\n\r\nThis object is used to match an incoming request to stubby against the available endpoints that have been configured.\r\n\r\n#### url (required)\r\n\r\n* is a full-fledged __regular expression__\r\n* This is the only required property of an endpoint.\r\n* signify the url after the base host and port (i.e. after `localhost:8882`).\r\n* any query paramters are stripped (so don't include them, that's what `query` is for).\r\n    * `/url?some=value&another=value` becomes `/url`\r\n* no checking is done for URI-encoding compliance.\r\n    * If it's invalid, it won't ever trigger a match.\r\n\r\nThis is the simplest you can get:\r\n```yaml\r\n-  request:\r\n      url: /\r\n```\r\n\r\nA demonstration using regular expressions:\r\n```yaml\r\n-  request:\r\n      url: ^/has/to/begin/with/this/\r\n\r\n-  request:\r\n      url: /has/to/end/with/this/$\r\n\r\n-  request:\r\n      url: ^/must/be/this/exactly/with/optional/trailing/slash/?$\r\n```\r\n\r\n#### method\r\n\r\n* defaults to `GET`.\r\n* case-insensitive.\r\n* can be any of the following:\r\n    * HEAD\r\n    * GET\r\n    * POST\r\n    * PUT\r\n    * POST\r\n    * DELETE\r\n    * etc.\r\n\r\n```yaml\r\n-  request:\r\n      url: /anything\r\n      method: GET\r\n```\r\n\r\n* it can also be an array of values.\r\n\r\n```yaml\r\n-  request:\r\n      url: /anything\r\n      method: [GET, HEAD]\r\n\r\n-  request:\r\n      url: ^/yonder\r\n      method:\r\n         -  GET\r\n         -  HEAD\r\n         -  POST\r\n```\r\n\r\n#### query\r\n\r\n* values are full-fledged __regular expressions__\r\n* if ommitted, stubby ignores query parameters for the given url.\r\n* a yaml hashmap of variable/value pairs.\r\n* allows the query parameters to appear in any order in a uri\r\n\r\n* The following will match either of these:\r\n    * `/with/parameters?search=search+terms&filter=month`\r\n    * `/with/parameters?filter=month&search=search+terms`\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/with/parameters$\r\n      query:\r\n         search: search terms\r\n         filter: month\r\n```\r\n\r\n#### post\r\n\r\n* is a full-fledged __regular expression__\r\n* if ommitted, any post data is ignored.\r\n* the body contents of the server request, such as form data.\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/post/form/data$\r\n      post: name=John&email=john@example.com\r\n```\r\n\r\n#### file\r\n\r\n* if supplied, replaces `post` with the contents of the locally given file.\r\n    * paths are relative from where the `--data` file is located\r\n* if the file is not found when the request is made, falls back to `post` for matching.\r\n* allows you to split up stubby data across multiple files\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/match/against/file$\r\n      file: postedData.json\r\n      post: '{\"fallback\":\"data\"}'\r\n```\r\n\r\npostedData.json\r\n```json\r\n{\"fileContents\":\"match against this if the file is here\"}\r\n```\r\n\r\n* if `postedData.json` doesn't exist on the filesystem when `/match/against/file` is requested, stubby will match post contents against `{\"fallback\":\"data\"}` (from `post`) instead.\r\n\r\n#### headers\r\n\r\n* values are full-fledged __regular expressions__\r\n* if ommitted, stubby ignores headers for the given url.\r\n* case-insensitive matching of header names.\r\n* a hashmap of header/value pairs similar to `query`.\r\n\r\nThe following endpoint only accepts requests with `application/json` post values:\r\n\r\n```yaml\r\n-  request:\r\n      url: /post/json\r\n      method: post\r\n      headers:\r\n         content-type: application/json\r\n```\r\n\r\n### response\r\n\r\nAssuming a match has been made against the given `request` object, data from `response` is used to build the stubbed response back to the client.\r\n\r\n__ALSO:__ The `response` property can also be a yaml sequence of responses that cycle as each request is made.\r\n__ALSO:__ The `response` property can also be a url (string) or sequence of object/urls. The url will be used to record a response object to be used in calls to stubby. When used this way, data from the `request` portion of the endpoint will be used to assemble a request to the url given as the `response`.\r\n\r\n```yaml\r\n- request:\r\n    url: /single/object\r\n  response:\r\n    status: 204\r\n\r\n- request:\r\n    url: /single/url/to/record\r\n  response: http://example.com\r\n\r\n- request:\r\n    url: /object/and/url/in/sequence\r\n  response:\r\n  - http://google.com\r\n  - status: 200\r\n    body: 'second hit'\r\n```\r\n\r\n#### status\r\n\r\n* the HTTP status code of the response.\r\n* integer or integer-like string.\r\n* defaults to `200`.\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/im/a/teapot$\r\n      method: POST\r\n   response:\r\n      status: 420\r\n```\r\n\r\n#### body\r\n\r\n* contents of the response body\r\n* defaults to an empty content body\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/give/me/a/smile$\r\n   response:\r\n      body: ':)'\r\n```\r\n\r\n#### file\r\n\r\n* similar to `request.file`, but the contents of the file are used as the `body`.\r\n\r\n```yaml\r\n-  request:\r\n      url: /\r\n   response:\r\n      file: extremelyLongJsonFile.json\r\n```\r\n\r\n#### headers\r\n\r\n* similar to `request.headers` except that these are sent back to the client.\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/give/me/some/json$\r\n   response:\r\n      headers:\r\n         content-type: application/json\r\n      body: >\r\n         [{\r\n            \"name\":\"John\",\r\n            \"email\":\"john@example.com\"\r\n         },{\r\n            \"name\":\"Jane\",\r\n            \"email\":\"jane@example.com\"\r\n         }]\r\n```\r\n\r\n#### latency\r\n\r\n* time to wait, in milliseconds, before sending back the response\r\n* good for testing timeouts, or slow connections\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/hello/to/jupiter$\r\n   response:\r\n      latency: 800000\r\n      body: Hello, World!\r\n```\r\n\r\n## Dynamic Token Replacement\r\n\r\nWhile `stubby` is matching request data against configured endpoints, it is keeping a hash of all regular expression capture groups along the way.\r\nThese capture groups can be referenced in `response` data. Here's an example\r\n\r\n```yaml\r\n-  request:\r\n      method: [GET]\r\n      url: ^/account/(\\d{5})/category/([a-zA-Z]+)\r\n      query:\r\n         date: \"([a-zA-Z]+)\"\r\n      headers:\r\n         custom-header: \"[0-9]+\"\r\n\r\n   response:\r\n      status: 200\r\n      body: Returned invoice number# <% url[1] %> in category '<% url[2] %>' on the date '<% query.date[1] %>', using header custom-header <% headers.custom-header[0] %>\r\n```\r\n\r\n###Example explained\r\n\r\nThe url regex `^/account/(\\d{5})/category/([a-zA-Z]+)` has two defined capturing groups: `(\\d{5})` and `([a-zA-Z]+)`, query regex has one defined capturing group `([a-zA-Z]+)`. In other words, a manually defined capturing group has parenthesis around it.\r\n\r\nAlthough, the headers regex does not have capturing groups defined explicitly (no regex sections within parenthesis), its matched value is still accessible in a template (keep on reading!).\r\n\r\n###Token structure\r\n\r\nThe tokens in response body follow the format of `< %PROPERTY_NAME[CAPTURING_GROUP_ID] %>`. If it is a token that should correspond to headers or query regex match, then the token structure would be as follows: `<% HEADERS_OR_QUERY.[KEY_NAME][CAPTURING_GROUP_ID] %>.\r\n\r\n###Numbering the tokens based on capturing groups without sub-groups\r\n\r\nWhen giving tokens their ID based on the count of manually defined capturing groups within regex, you should start from `1`, not zero (zero reserved for token that holds __full__ regex match) from left to right. So the leftmost capturing group would be `1` and the next one to the right of it would be `2`, etc.\r\n\r\nIn other words `<% url[1] %>` and `<% url[2] %>` tokens correspond to two capturing groups from the url regex `(\\d{5})` and `([a-zA-Z]+)`, while `<% query.date[1] %>` token corresponds to one capturing group `([a-zA-Z]+)` from the `query` `date` property regex.\r\n\r\n###Numbering the tokens based on capturing groups with sub-groups\r\n\r\nIn regex world, capturing groups can contain capturing sub-groups, as an example consider proposed `url` regex: `^/resource/(([a-z]{3})-([0-9]{3}))$`. In the latter example, the regex has three groups - a parent group `([a-z]{3}-[0-9]{3})` and two sub-groups within: `([a-z]{3})` & `([0-9]{3})`.\r\n\r\nWhen giving tokens their ID based on the count of capturing groups, you should start from 1, not zero (zero reserved for token that holds __full__ regex match) from left to right. If a group has sub-group within, you count the sub-group(s) first (also from left to right) before counting the next one to the right of the parent group.\r\n\r\nIn other words tokens `<% url[1] %>`, `<% url[2] %>` and `<% url[3] %>` correspond to the three capturing groups from the url regex (starting from left to right): `([a-z]{3}-[0-9]{3})`, `([a-z]{3})` and `([0-9]{3})`.\r\n\r\n###Tokens with ID zero\r\n\r\nTokens with ID zero can obtain `full` match value from the regex they reference. In other words, tokens with ID zero do not care whether regex has capturing groups defined or not. For example, token `<% url[0] %>` will be replaced with the `ur`l __full__ regex match from `^/account/(\\d{5})/category/([a-zA-Z]+)`. So if you want to access the `url` __full__ regex match, respectively you would use token `<% url[0] %>` in your template.\r\n\r\nAnother example, would be the earlier case where `headers` `custom-header` property regex does not have capturing groups defined within. Which is fine, since the `<% headers.custom-header[0] %>` token corresponds to the __full__ regex match in the `header` `custom-header` property regex: `[0-9]+`.\r\n\r\nIt is also worth to mention, that the __full__ regex match value replacing token `<% query.date[0] %>`, would be equal to the regex capturing group value replacing `<% query.date[1] %>`. This is due to how the `query` `date` property regex is defined - the one and only capturing group in the query date regex, is also the __full__ regex itself.\r\n\r\n###Where to specify the template\r\n\r\nYou can specify template with tokens in both `body` as a string or using `file` by specifying template as external local file. When template is specified as `file`, the contents of local file from `file` will be replaced, __not__ the path to local file defined in `file`.\r\n\r\n###When token interpolation happens\r\n\r\nAfter successful HTTP request verification, if your body or contents of local file from file contain tokens - the tokens will be replaced just before rendering HTTP response.\r\n\r\n### Troubleshooting\r\n\r\n* Make sure that the regex you used in your stubby configuration actually does what it suppose to do. Validate that it works before using it in stubby\r\n* Make sure that the regex has capturing groups for the parts of regex you want to capture as token values. In other words, make sure that you did not forget the parenthesis within your regex if your token IDs start from `1`\r\n* Make sure that you are using token ID zero, when wanting to use __full__ regex match as the token value\r\n* Make sure that the token names you used in your template are correct: check that property name is correct, capturing group IDs, token ID of the __full__ match, the `<%` and `%>`\r\n\r\n## The Admin Portal\r\n\r\nThe admin portal is a RESTful(ish) endpoint running on `localhost:8889`. Or wherever you described through stubby's options.\r\n\r\n### Supplying Endpoints to Stubby\r\n\r\nSubmit `POST` requests to `localhost:8889` or load a data-file (-d) with the following structure for each endpoint:\r\n\r\n* `request`: describes the client's call to the server\r\n   * `method`: GET/POST/PUT/DELETE/etc.\r\n   * `url`: the URI regex string.\r\n   * `query`: a key/value map of query string parameters included with the request\r\n   * `headers`: a key/value map of headers the server should respond to\r\n   * `post`: a string matching the textual body of the response.\r\n   * `file`: if specified, returns the contents of the given file as the request post. If the file cannot be found at request time, **post** is used instead\r\n* `response`: describes the server's response to the client\r\n   * `headers`: a key/value map of headers the server should use in it's response\r\n   * `latency`: the time in milliseconds the server should wait before responding. Useful for testing timeouts and latency\r\n   * `file`: if specified, returns the contents of the given file as the response body. If the file cannot be found at request time, **body** is used instead\r\n   * `body`: the textual body of the server's response to the client\r\n   * `status`: the numerical HTTP status code (200 for OK, 404 for NOT FOUND, etc.)\r\n\r\n#### YAML (file only)\r\n```yaml\r\n-  request:\r\n      url: ^/path/to/something$\r\n      method: POST\r\n      headers:\r\n         authorization: \"Basic usernamez:passwordinBase64\"\r\n      post: this is some post data in textual format\r\n   response:\r\n      headers:\r\n         Content-Type: application/json\r\n      latency: 1000\r\n      status: 200\r\n      body: You're request was successfully processed!\r\n\r\n-  request:\r\n      url: ^/path/to/anotherThing\r\n      query:\r\n         a: anything\r\n         b: more\r\n      method: GET\r\n      headers:\r\n         Content-Type: application/json\r\n      post:\r\n   response:\r\n      headers:\r\n         Content-Type: application/json\r\n         Access-Control-Allow-Origin: \"*\"\r\n      status: 204\r\n      file: path/to/page.html\r\n\r\n-  request:\r\n      url: ^/path/to/thing$\r\n      method: POST\r\n      headers:\r\n         Content-Type: application/json\r\n      post: this is some post data in textual format\r\n   response:\r\n      headers:\r\n         Content-Type: application/json\r\n      status: 304\r\n```\r\n\r\n#### JSON (file or POST/PUT)\r\n```json\r\n[\r\n  {\r\n    \"request\": {\r\n      \"url\": \"^/path/to/something$\",\r\n      \"post\": \"this is some post data in textual format\",\r\n      \"headers\": {\r\n         \"authorization\": \"Basic usernamez:passwordinBase64\"\r\n      },\r\n      \"method\": \"POST\"\r\n    },\r\n    \"response\": {\r\n      \"status\": 200,\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      \"latency\": 1000,\r\n      \"body\": \"You're request was successfully processed!\"\r\n    }\r\n  },\r\n  {\r\n    \"request\": {\r\n      \"url\": \"^/path/to/anotherThing\",\r\n      \"query\": {\r\n         \"a\": \"anything\",\r\n         \"b\": \"more\"\r\n      },\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      \"post\": null,\r\n      \"method\": \"GET\"\r\n    },\r\n    \"response\": {\r\n      \"status\": 204,\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\",\r\n        \"Access-Control-Allow-Origin\": \"*\"\r\n      },\r\n      \"file\": \"path/to/page.html\"\r\n    }\r\n  },\r\n  {\r\n    \"request\": {\r\n      \"url\": \"^/path/to/thing$\",\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      \"post\": \"this is some post data in textual format\",\r\n      \"method\": \"POST\"\r\n    },\r\n    \"response\": {\r\n      \"status\": 304,\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      }\r\n    }\r\n  }\r\n]\r\n```\r\n\r\nIf you want to load more than one endpoint via file, use either a JSON array or YAML list (-) syntax. On success, the response will contain `Location` in the header with the newly created resources' location\r\n\r\n### Getting the ID of a Loaded Endpoint\r\n\r\nStubby adds the response-header `X-Stubby-Resource-ID` to outgoing responses. This ID can be referenced for use with the Admin portal.\r\n\r\n### Getting the Current List of Stubbed Endpoints\r\n\r\nPerforming a `GET` request on `localhost:8889` will return a JSON array of all currently saved responses. It will reply with `204 : No Content` if there are none saved.\r\n\r\nPerforming a `GET` request on `localhost:8889/<id>` will return the JSON object representing the response with the supplied id.\r\n\r\n#### The Status Page\r\n\r\nYou can also view the currently configured endpoints by going to `localhost:8889/status`\r\n\r\n### Changing Existing Endpoints\r\n\r\nPerform `PUT` requests in the same format as using `POST`, only this time supply the id in the path. For instance, to update the response with id 4 you would `PUT` to `localhost:8889/4`.\r\n\r\n### Deleting Endpoints\r\n\r\nSend a `DELETE` request to `localhost:8889/<id>`\r\n\r\n## The Stubs Portal\r\n\r\nRequests sent to any url at `localhost:8882` (or wherever you told stubby to run) will search through the available endpoints and, if a match is found, respond with that endpoint's `response` data\r\n\r\n### How Endpoints Are Matched\r\n\r\nFor a given endpoint, stubby only cares about matching the properties of the request that have been defined in the YAML. The exception to this rule is `method`; if it is omitted it is defaulted to `GET`.\r\n\r\nFor instance, the following will match any `POST` request to the root url:\r\n\r\n```yaml\r\n-  request:\r\n      url: /\r\n      method: POST\r\n   response: {}\r\n```\r\n\r\nThe request could have any headers and any post body it wants. It will match the above.\r\n\r\nPseudocode:\r\n\r\n```\r\nfor each <endpoint> of stored endpoints {\r\n\r\n   for each <property> of <endpoint> {\r\n      if <endpoint>.<property> != <incoming request>.<property>\r\n         next endpoint\r\n   }\r\n\r\n   return <endpoint>\r\n}\r\n```\r\n\r\n## Programmatic API\r\n\r\n### The Stubby module\r\n\r\nAdd `stubby` as a module within your project's directory:\r\n\r\n```\r\n    npm install stubby\r\n```\r\n\r\nThen within your project files you can do something like:\r\n\r\n```javascript\r\n    var Stubby = require('stubby').Stubby;\r\n    var mockService = new Stubby();\r\n\r\n    mockService.start();\r\n```\r\n\r\nWhat can I do with it, you ask? Read on!\r\n\r\n#### start(options, [callback])\r\n\r\n* `options`: an object containing parameters with which to start this stubby. Parameters go along with the full-name flags used from the command line.\r\n   * `stubs`: port number to run the stubs portal\r\n   * `admin`: port number to run the admin portal\r\n   * `tls`: port number to run the stubs portal over https\r\n   * `data`: JavaScript Object/Array containing endpoint data\r\n   * `location`: address/hostname at which to run stubby.\r\n   * `key`: keyfile contents (in PEM format)\r\n   * `cert`: certificate file contents (in PEM format)\r\n   * `pfx`: pfx file contents (mutually exclusive with key/cert options)\r\n   * `watch`: filename to monitor and load as stubby's data when changes occur\r\n   * `mute`: defaults to `true`. Pass in `false` to have console output (if available)\r\n* `callback`: takes one parameter: the error message (if there is one), undefined otherwise\r\n\r\n#### start([callback])\r\nIdentical to previous signature, only all options are assumed to be defaults.\r\n\r\n#### stop([callback])\r\ncloses the connections and ports being used by stubby's stubs and admin portals. Executes `callback` afterward.\r\n\r\n#### get(id, callback)\r\nSimulates a GET request to the admin portal, with the callback receiving the resultant data.\r\n\r\n* `id`: the id of the endpoint to retrieve. If ommitted, an array of all registered endpoints is passed the callback.\r\n* `callback(err, endpoint)`: `err` is defined if no endpoint exists with the given id. Else, `endpoint` is populated.\r\n\r\n#### get(callback)\r\nSimulates a GET request to the admin portal, with the callback receiving the resultant data.\r\n\r\n* `id`: the id of the endpoint to retrieve. If ommitted, an array of all registered endpoints is passed the callback.\r\n* `callback(endpoints)`: takes a single parameter containing an array of returned results. Empty if no endpoints are registered\r\n\r\n#### post(data, [callback])\r\n* `data`: an endpoint object to store in stubby\r\n* `callback(err, endpoint)`: if all goes well, gets executed with the created endpoint. If there is an error, gets called with the error message.\r\n\r\n#### put(id, data, [callback])\r\n* `id`: id of the endpoint to update.\r\n* `data`: data with which to replace the endpoint.\r\n* `callback(err)`: executed with no passed parameters if successful. Else, passed the error message.\r\n\r\n#### delete([id], callback)\r\n* `id`: id of the endpoint to destroy. If ommitted, all endoints are cleared from stubby.\r\n* `callback()`: called after the endpoint has been removed\r\n\r\n#### Example\r\n```javascript\r\nvar Stubby = require('stubby').Stubby;\r\n\r\nvar stubby1 = new Stubby();\r\nvar stubby2 = new Stubby();\r\n\r\nstubby1.start({\r\n  stubs: 80,\r\n  admin: 81,\r\n  location: 'localhost',\r\n  data: [{\r\n    request: { url: \"/anywhere\" }\r\n  },{\r\n    request: { url: \"/but/here\" }\r\n  }]\r\n});\r\n\r\nstubby2.start({\r\n  stubs: 82,\r\n  admin: 83,\r\n  location: '127.0.0.2'\r\n});\r\n```\r\n\r\n## Running Tests\r\n\r\nIf you don't have `grunt-cli` already, install it:\r\n\r\n    npm install -g grunt-cli\r\n    npm install\r\n\r\nFrom the root directory run:\r\n\r\n    grunt test\r\n\r\n## Contributing\r\n\r\nFork, modify, request a pull. If changes are significant or touch more than one\r\npart of the system, tests are suggested.\r\n\r\nIf large pull requests do not have tests there may be some push back until\r\nfunctionality can be verified :)\r\n\r\n## See Also\r\n\r\n* **[stubby4j](https://github.com/azagniotov/stubby4j):** A java implementation of stubby\r\n* **[stubby4net](https://github.com/mrak/stubby4net):** A .NET implementation of stubby\r\n* **[grunt-stubby](https://github.com/h2non/grunt-stubby):** grunt integration with stubby\r\n\r\n## TODO\r\n\r\n* `post` parameter as a hashmap under `request` for easy form-submission value matching\r\n* record & replay\r\n\r\n## NOTES\r\n\r\n* __Copyright__ 2014 Eric Mrak, Alexander Zagniotov\r\n* __License__ Apache v2.0\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}